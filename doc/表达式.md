# 表达式

## 1. 运算符

 优先级与结合性

- 算术运算符 > 比较运算符 > 逻辑运算符
- 左结合：`+`, `-`, `*`, `/`, `%`
- 右结合：`=`, `+=`, `-=`, `*=`, `/=`, `%=` 等

### 算术运算符

- **特殊行为**：整数除法向零取整，除零会 panic
- **安全版本**：`checked_div()` 返回 `Option`
- **注意**：无一元 `+`，无自增 `++`/自减 `--`

### 逻辑运算符

- `&&` 和 `||` 短路求值，操作数必须是 `bool` 类型
- `!` 表示逻辑非（对于整数是按位非）

### 比较运算符

- 两个操作数必须是相同类型
- 无三元运算符 `?:`，使用 `if` 表达式代替

### 表达式 vs 语句

- **表达式**：计算并返回值
- **语句**：执行操作但不返回值

### 块与分号

块是用花括号 `{}` 包裹的代码片段，可以包含多个语句。块的最后一个表达式的值就是整个块的值。分号用于结束语句，但在块的最后一个表达式后面不需要分号。

```rust
let x = {
    let y = 1;
    y + 1  // 最后一个表达式，无分号，作为块的返回值
};      // x = 2
```

## 2. 控制流

### 条件表达式

```rust
// if 表达式
let number = if condition { 5 } else { 6 };

// if let 模式匹配
if let Some(x) = option_value {
    println!("{}", x);
}

// match 表达式
let result = match value {
    1 => "one",
    2 => "two",
    _ => "other",
};
```

### 循环

   1. while / while let

   2. for..in 遍历集合或范围。

   3. loop 创建一个无限循环。

   1. while let
   `while let` 是一种用于模式匹配的循环结构，它会在每次迭代时尝试匹配给定的模式。如果匹配成功，则执行循环体；如果匹配失败，则退出循环。这种结构在处理可选值或枚举时非常有用。
    例如，可以使用 `while let Some(x) = option` 来处理 `Option` 类型的值，直到它变为 `None`。
   2. 循环中的控制流
   Rust 提供了 `break` 和 `continue` 关键字来控制循环的流。`break` 用于退出循环，而 `continue` 用于跳过当前迭代，直接进入下一次循环。
   3. 循环标签
   Rust 允许为循环添加标签，以便在嵌套循环中更清晰地控制流。标签以单引号开头，紧跟在循环关键字前面。例如，`'outer loop` 可以用于标记外层循环。
   4. return 表达式
   在 Rust 中，`return` 关键字用于从函数中返回一个值。它可以在函数的任何位置使用，并且可以在函数体内的任何表达式后面使用。使用 `return` 可以提前退出函数并返回指定的值。

   5. 函数与方法调用
   在 Rust 中，函数和方法调用是通过名称和参数来执行的。函数调用使用 `fn` 关键字定义，而方法调用则是结构体或枚举上的函数。方法调用通常使用点语法，调用者可能是值或引用，也可能是智能指针，.运算符会根据具体情况自动解引用或借用。
   类型关联函数是定义在类型上的函数，而不是在实例上调用的函数。类型关联函数使用 `::` 语法调用，例如 `Type::associated_function()`。
   在函数调用或方法调用中，泛型类型的常用语法<T>是不起作用的，需要使用::<T>来指定泛型类型或省略类型参数采用类型自动推导。

   6. 字段与元素
    在 Rust 中，字段和元素是结构体和元组的组成部分。字段是结构体中的命名数据项，而元素是元组中的位置数据项。可以通过点语法访问结构体的字段，例如 `struct_instance.field_name`，或者通过索引访问元组的元素，例如 `tuple_instance.0`。
    结构体的字段可以是可变的，而元组的元素通常是不可变的。可以使用 `mut` 关键字来声明可变的结构体实例，从而允许修改其字段值。
    元组的元素可以通过模式匹配来解构，从而方便地访问和使用它们的值。
    `[]`会访问数组、切片或向量的元素，而`.`会访问结构体的字段或元组中的元素。它们左侧的值会自动解引用或借用，以便访问相应的元素或字段。
   7. `..`运算符会生成一个范围，即具有两个字段的简单结构体。`..=`运算符会生成包含结束值的范围。如果省略了范围起点或终点值，则会使用被切片数据的起点或终点值。

   8. 引用运算符和解引用运算符
   在 Rust 中，引用运算符 `&` 用于创建一个对值的引用，而解引用运算符 `*` 用于访问引用所指向的值。引用可以是可变的或不可变的，解引用运算符会根据引用的类型自动进行解引用。

   9. 算术运算符、按位运算符、比较运算符和逻辑运算符
    整数除法会向0取整，除数为0会触发panic。checked_div()方法会返回Option类型，除数为0时返回None。
    一元运算符`-`会对一个除无符号整数之外的所有数值类型取负。没有一元`+`运算符。
    Rust使用`!`运算符表示按位非。对于整数n，不能使用`!n`表示“n为0”。
    移位运算符总是对有符号整数类型进行符号扩展，而对无符号整数类型进行零扩展。因此无需无符号右移运算符`>>>`。
    Rust中按位运算符的优先级高于比较运算符。
    Rust中参与比较运算的两个值必须具有相同的类型。
    Rust中短路逻辑运算符&&和||,它们的操作数必须具有确切的bool类型。
    赋值运算符用于给mut变量及其字段或元素赋值。如果值是非Copy类型，则会发生所有权移动。支持复合赋值，但不支持链式赋值。
    Rust中没有三元运算符`?:`，可以使用`if`表达式代替。
    Rust中没有自增和自减运算符`++`和`--`。
   10. 类型转换
    Rust中没有隐式类型转换，所有类型转换都需要显式地使用`as`关键字。可以使用`as`将整数类型转换为其他整数类型、浮点数类型或字符类型。
    对于字符串和字符的转换，可以使用`to_string()`方法将字符串切片转换为`String`，或使用`String::from()`函数创建一个新的字符串。
    Rust还提供了`From`和`Into`特性来进行类型转换，这些特性允许在不同类型之间进行转换，并且可以通过实现这些特性来定义自定义的转换逻辑。
    - 数值类型可以在任意内置数值类型之间进行转换。转换为更窄的类型可能会导致截断，转换为更宽的有符号类型会进行符号扩展，转换为无符号类型会进行零扩展。从浮点数转换为整数类型会向0舍入。
    - bool类型或char类型或者类C的enum类型的可以转换为任意整型，但不允许相反方向的转换。例外的是u8可以转换为char类型。
    - 一些不涉及安全指针类型的转换也是允许的。
    - 几种重要的自动转换:
      - `String`类型的值会自动转换为`&str`类型，无需强制转换。
      - `&Vec<T>`类型的值会自动转换为`&[T]`类型。
      - `&Box<T>`类型的值会自动转换为`&T`类型。
    隐式解引用 所有实现了`Deref`特性的类型都可以隐式地解引用为其目标类型。
   11. 闭包
    Rust中的闭包是可以捕获其环境的匿名函数。闭包可以访问其定义所在作用域中的变量，并且可以根据需要捕获这些变量的所有权或借用。
    闭包的语法使用`|参数| 表达式`来定义，其中参数列表可以为空或包含一个或多个参数。闭包可以返回一个值，也可以没有返回值。
    闭包的类型是根据其捕获的变量和参数类型自动推导的，因此不需要显式地指定类型。
    闭包可以作为函数参数传递，也可以作为函数返回值返回，从而实现更灵活的编程模式。
    Rust中的闭包可以使用`move`关键字来强制捕获变量的所有权，而不是借用。这对于在多线程环境中使用闭包非常有用。
    闭包可以使用`Fn`、`FnMut`和`FnOnce`特性来指定其调用方式。`Fn`表示不可变借用，`FnMut`表示可变借用，`FnOnce`表示获取所有权。
    闭包可以使用`let`语句来定义变量，并在闭包内部使用这些变量。闭包可以通过调用来执行，并且可以将其作为参数传递给其他函数。
    Rust中的闭包可以使用`async`关键字来定义异步闭包，从而支持异步编程模型。异步闭包可以使用`await`关键字来等待异步操作的结果，并且可以返回一个实现了`Future`特性类型的值。

## 4. 访问操作

### 字段与元素

```rust
// 结构体字段
struct.field_name

// 元组元素
tuple.0

// 数组/向量元素
array[index]
vec[index]

// 范围操作
0..10     // 不包含结尾
0..=10    // 包含结尾
..10      // 从开始到10
10..      // 从10到结尾
```

## 5. 引用与解引用

```rust
let x = 5;
let r = &x;     // 引用
let v = *r;     // 解引用

// 自动解引用在方法调用和字段访问中发生
```

## 7. 类型转换

### 显式转换

```rust
let x = 42i32;
let y = x as f64;        // 使用 as 关键字
let s = x.to_string();   // 转换为字符串
```

### 自动转换（Deref Coercion）

```rust
String → &str            // 字符串切片
&Vec<T> → &[T]          // 数组切片
&Box<T> → &T            // 智能指针解引用
```

### From/Into 特性

```rust
let s = String::from("hello");
let s: String = "hello".into();
```

## 8. 闭包

### 语法与特性

```rust
// 基本语法
|param1, param2| expression
|param| { statements; expression }

// 捕获模式
let closure = |x| x + captured_var;     // 借用
let closure = move |x| x + captured_var; // 移动所有权

// 特性约束
fn take_closure<F>(f: F) where F: Fn(i32) -> i32 { }     // 不可变借用
fn take_closure<F>(f: F) where F: FnMut(i32) -> i32 { }  // 可变借用
fn take_closure<F>(f: F) where F: FnOnce(i32) -> i32 { } // 获取所有权
```

### 异步闭包

```rust
let async_closure = async |x| {
    some_async_operation(x).await
};
```

## 9. 重要特性

- **类型安全**：无隐式类型转换，严格类型检查
- **所有权**：表达式求值可能涉及所有权转移
- **模式匹配**：强大的解构和匹配能力
- **零成本抽象**：闭包和迭代器在运行时无额外开销
