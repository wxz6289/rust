# 所有权

如何管理内存的一组规则。
栈和堆
栈中的所有数据都必须占用已知且固定的大小。在编译时大小未知或大小可能变化的数据，要改为存储在堆上。
跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。

所有权规则

- Rust 中的每一个值都有一个 所有者。
- 值在任一时刻有且只有一个所有者。
- 当所有者离开作用域，这个值将被丢弃。

在任意给定时间，要么只能有一个可变引用，要么只能有多个不可变引用。
引用必须总是有效的。

Rust中内存在拥有它的变量离开作用域后就被自动释放。
Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何自动的复制都可以被认为是对运行时性能影响较小的。
当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。

1. 内存安全
自动管理内存分配和释放，无需手动调用 free/delete，避免悬垂指针、野指针等内存安全隐患。
1. 数据竞争
在多线程环境下，通过所有权和借用规则，编译期就能发现潜在的数据竞争（多个线程同时读写同一内存导致未定义行为）。
1. 资源泄漏
保证资源（如文件句柄、网络连接等）在生命周期结束时自动释放，避免资源泄漏。
1. 防止重复释放
避免“二次释放”或“重复释放”内存，防止程序崩溃或安全漏洞。
1. 明确数据归属
让每个值都有唯一的拥有者，数据的归属和生命周期清晰，易于理解和维护。

拥有者和拥有的值构成了一个树。

- 拥有者可以将值转移给另外一个拥有者。允许构建、重新排列和拆除树型结构。
- 简单类型不受所有权约束。Copy类型
- 可以对值进行“借用”,以获得值的引用 非拥有型指针 受限的生命周期

赋值、传参、调用函数返回等操作都不会复制值，而是`移动值`。移动的永远是值本身，而不是这些值的堆存储。
在Rust中，大多数类型的赋值操作会将值从源转移给目标，而源会回到未初始化状态。

常见Copy类型

- 整型
- 浮点型
- char
- bool
- Copy类型组成的元组或固定大小的数组

struct类型和enum类型默认不是Copy类型

## 引用 `&`

同一时间对同一数据不能存在多个可变引用。
Rust 在同时使用可变与不可变引用时也强制采用类似的规则。

- 无需复制数据
引用允许在不复制数据的情况下访问原始值，节省内存和提升性能。

- 安全访问
通过编译器的借用检查，引用保证不会出现悬垂指针、数据竞争等安全问题。

- 灵活共享
共享引用（&T）可以让多个地方只读访问同一数据，方便数据共享和并发读。

- 独占修改
可变引用（&mut T）保证同一时刻只有一个地方能修改数据，防止并发写导致的未定义行为。

- 生命周期管理
Rust 编译器自动跟踪引用的生命周期，确保引用始终有效，防止野指针和内存泄漏。

- 提升代码可读性和可维护性
明确的数据归属和访问方式，让代码逻辑更清晰，易于维护和理解。

不影响所有权的情况下访问值。

- 共享引用 允许读取值但不能改变其引用目标 可以创建任意数量的对特定值的共享引用 Copy类型
- 可变引用 允许读取和修改值 只能创建一个 独占值的访问权 不是Copy类型

数据竞争造成原因：

- 两个或更多指针同时访问同一数据。
- 至少有一个指针被用来写入数据。
- 没有同步数据访问的机制。

## 借用

借用是指在不获取所有权的情况下，临时使用某个值。Rust通过借用机制来实现对数据的安全访问。

- 共享借用（&T）：允许多个读者同时访问数据，但不允许修改。可以创建任意数量的共享借用。
- 可变借用（&mut T）：允许唯一的写者修改数据，但在此期间不允许其他任何借用（包括共享借用）。可变借用是独占的。
- 生命周期：借用有生命周期，确保引用在使用时始终有效。Rust编译器通过生命周期检查来防止悬垂引用和数据竞争。

## 引用和借用的关系

“引用”是 Rust 的类型系统中的一种指针类型，而“借用”是通过引用实现的数据访问方式，强调的是临时使用但不拥有数据的语义。

- 引用是语法层面的类型，借用是语义层面的行为。
- 当你创建 &T 或 &mut T 时，就是在“借用”这个值。
- 借用的本质就是通过引用来实现的。

## 解引用 `*`

## 切片

切片（slice）允许你引用集合中一段连续的元素序列，而不用引用整个集合。
